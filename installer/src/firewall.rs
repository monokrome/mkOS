//! Firewall setup using nftables

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

use crate::distro::Distro;
use crate::init::ServiceSpec;
use crate::manifest::{FirewallConfig, FirewallRule};

/// Set up nftables firewall based on configuration
pub fn setup_firewall(root: &Path, config: &FirewallConfig, distro: &dyn Distro) -> Result<()> {
    if !config.enabled {
        return Ok(());
    }

    // Install nftables package
    distro.install_packages(root, &["nftables"])?;

    // Generate and write nftables configuration
    let nft_config = generate_nftables_config(config);
    fs::write(root.join("etc/nftables.conf"), &nft_config)
        .context("Failed to write /etc/nftables.conf")?;

    // Create oneshot service to load rules at boot
    let nftables_service = ServiceSpec::oneshot(
        "nftables",
        "nft -f /etc/nftables.conf",
    );

    let init = distro.init_system();
    init.create_service(root, &nftables_service)?;
    init.enable_service(root, "nftables")?;

    Ok(())
}

/// Generate nftables configuration file content
fn generate_nftables_config(config: &FirewallConfig) -> String {
    let mut rules = String::new();

    rules.push_str("#!/usr/sbin/nft -f\n\n");
    rules.push_str("# mkOS firewall configuration\n");
    rules.push_str("# Generated by mkos-install\n\n");
    rules.push_str("flush ruleset\n\n");
    rules.push_str("table inet filter {\n");

    // Input chain with secure defaults
    rules.push_str("    chain input {\n");
    rules.push_str(&format!(
        "        type filter hook input priority 0; policy {};\n\n",
        config.defaults.input
    ));
    rules.push_str("        # Accept loopback traffic\n");
    rules.push_str("        iif lo accept\n\n");
    rules.push_str("        # Accept established and related connections\n");
    rules.push_str("        ct state established,related accept\n");
    rules.push_str("        ct state invalid drop\n\n");
    rules.push_str("        # Accept ICMP (ping)\n");
    rules.push_str("        ip protocol icmp accept\n");
    rules.push_str("        ip6 nexthdr icmpv6 accept\n\n");

    // Add custom rules
    for rule in &config.rules {
        rules.push_str(&format_rule(rule));
    }

    rules.push_str("    }\n\n");

    // Forward chain
    rules.push_str("    chain forward {\n");
    rules.push_str(&format!(
        "        type filter hook forward priority 0; policy {};\n",
        config.defaults.forward
    ));
    rules.push_str("    }\n\n");

    // Output chain
    rules.push_str("    chain output {\n");
    rules.push_str(&format!(
        "        type filter hook output priority 0; policy {};\n",
        config.defaults.output
    ));
    rules.push_str("    }\n");

    rules.push_str("}\n");
    rules
}

/// Format a single firewall rule as nftables syntax
fn format_rule(rule: &FirewallRule) -> String {
    let mut line = format!("        # {}\n        ", rule.name);

    // Source IP restriction
    if let Some(src) = &rule.source {
        line.push_str(&format!("ip saddr {} ", src));
    }

    // Protocol and port(s)
    if let Some(port) = rule.port {
        line.push_str(&format!("{} dport {} accept\n\n", rule.protocol, port));
    } else if let Some(ports) = &rule.ports {
        let port_list: Vec<String> = ports.iter().map(|p| p.to_string()).collect();
        line.push_str(&format!(
            "{} dport {{ {} }} accept\n\n",
            rule.protocol,
            port_list.join(", ")
        ));
    }

    line
}
